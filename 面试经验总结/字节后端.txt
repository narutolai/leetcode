1.TCP,UDP介绍,差别, 连接安全效率对象。
连bai接方面区别
TCP面向连接（如打电话要先拨号建立连du接）。
UDP是无连接zhi的，即发送数dao据之前不需要建立连接。
安全方面的区别
TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。
UDP尽最大努力交付，即不保证可靠交付。
传输效率的区别
TCP传输效率相对较低。
UDP传输效率高，适用于对高速传输和实时性有较高的通信或广播通信。
对象数量的区别
TCP连接只能是点到点、一对一的。
UDP支持一对一，一对多，多对一和多对多的交互通信

2.红黑树,AVL对比,引申B,B+树
平衡二叉树类型	平衡度	调整频率	适用场景
AVL树	          高	    高	    查询多，增/删少
红黑树	          低	    低	    增 /删频繁

AVL树就也是BST 一般用平衡因子判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，和红黑树相比，AVL树是高度平衡的二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。
执行插入还是删除操作后要通过旋转来保持平衡，而的由于旋转比较耗时，适合用于插入与删除次数比较少，但查找多的情况。
局限性：由于维护平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。
当然，如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。
是一种平衡二叉树，但每个节点有一个存储位表示节点的颜色，可以是红或黑。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，
因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度<=红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以适用于搜索，插入，删除操作较多的情况。
性质：
1. 每个节点非红即黑
2. 根节点是黑的;
3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;
4. 如图所示，如果一个节点是红的，那么它的两儿子都是黑的;
5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;
6. 每条路径都包含相同的黑节点;
应用：广泛用于C ++的STL中，地图是用红黑树实现的。

3.网卡收到一条数据到进程处理数据,这之间经历了什么(中断的上半部下半部,网络层协议拆包)
#https://blog.csdn.net/drdairen/article/details/83818154

4.大数据量(内存够用)下,快排与堆排序的对比(考察缓存命中率的对比)

5.缓存相关内容,LRU算法思想,手撕LRU的实现（最近最久未使用算法）

6.缓存失效,替换原理(操作系统的知识哦) 

7.C++多态原理#https://www.cnblogs.com/alinh/p/9636352.html
顺便可以去理解一下虚函数 虚表 构造函数先执行父类 再执行子类的析构相反。
C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。
如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数
总结(基类有虚函数的):
　　1:每一个类都有虚表
　　2:虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现，如果基类有3个虚函数，那么基类的虚表中就有三项(虚函数地址)，
     派生类也会虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现，如果派生类有自己的虚函数，那么虚表中就会添加该项。
　　3：派生类的虚表中虚地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。
　　这就是c++中的多态性，当c++编译器在编译的时候，发现Father类的Say()函数是虚函数，这个时候c++就会采用晚绑定技术，也就是编译时并不确定具体调用的函数
  而是在运行时，依据对象的类型来确认调用的是哪一个函数，这种能力就叫做c++的多态性，我们没有在Say()函数前加virtual关键字时，c++编译器就确定了哪个函数被调用，这叫做早期绑定。
　　c++的多态性就是通过晚绑定技术来实现的。
　　c++的多态性用一句话概括就是:在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。
　　虚函数是在基类中定义的，目的是不确定它的派生类的具体行为，例如:
　　定义一个基类:class Animal //动物，它的函数为breathe()
　　再定义一个类class Fish //鱼。它的函数也为breathe()
　　再定义一个类class Sheep //羊，它的函数也为breathe()
将Fish，Sheep定义成Animal的派生类，然而Fish与Sheep的breathe不一样，一个是在水中通过水来呼吸，一个是直接呼吸，所以基类不能确定该如何定义breathe，所以在基类中只定义了一个virtual breathe，它是一个空的虚函数，具体的函数在子类中分别定义，
程序一般运行时，找到类，如果它有基类，再找到它的基类，最后运行的是基类中的函数，这时，它在基类中找到的是virtual标识的函数，它就会再回到子类中找同名函数，派生类也叫子类，基类也叫父类，这就是虚函数的产生，和类的多态性的体现。
　　这里的多态性是指类的多态性。
　　函数的多态性是指一个函数被定义成多个不同参数的函数。当你调用这个函数时，就会调用不同的同名函数。
一般情况下(不涉及虚函数)，当我们用一个指针/引用调用一个函数的时候，被调用的函数是取决于这个指针/引用的类型。
当设计到多态性的时候，采用了虚函数和动态绑定，此时的调用就不会在编译时候确定而是在运行时确定。不在单独考虑指针/引用的类型而是看指针/引用的对象的类型来判断函数的调用，根据对象中虚指针指向的虚表中的函数的地址来确定调用哪个函数

8.32位系统运行大于4G的程序,如何寻址(考察虚拟内存,虚拟地址空间)

9.手撕完全二叉树寻找最后一行的最后一个节点(没做过,当时想到的是利用特性算出最后节点的层序序号,然后除二看奇偶,找出起点到最后节点的路径)
10.手撕层序遍历二叉树

11.平时看什么书,如何评价自己

12.STL vector扩容,map实现原理,红黑树,AVL
新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；
对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；
初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；
size是包含元素的个数 capacity是内存大小
不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容

上来直接撕代码：
1.M个不重复字符随机组合问是否在一个字符串中会出现，要求O(N)
2.M个重复字符（包括中文）随机组合，问会不会在一个字符串中出现，要求O(N)

然后就是基础知识：

1.内存中进程驻留集如何选定

2.调度算法

3.为什么要有TIME_WAIT，大小选定

4.超时重传

5.拥塞控制

6.数据库中文件在磁盘上的存储方式

7.B树
#https://blog.csdn.net/wyqwilliam/article/details/82935922 各种树的集合
B树是一种多路搜索树，就不一定是两个子节点了，比如该节点有2个数 那么就会有3个向下延申的节点
可以把b树当成m阶树，就是节点子树最大不能超过它。
B+ 树通常用于数据库和操作系统的文件系统中。
B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。

8.采用B树与二叉树的区别

9.外部查找：
在计算机中，存储器的层次结构一般分为：CPU寄存器、主存、辅存， [1]  外部查找是指在辅助设备空间进行数据查找。如在计算机中内存的大小是有限的， 
如果要查找的数据量太大，无法全部加载到内存中，必须借助辅助存储设备的空间再进行查找
13.手撕给二叉树先序,中序序列,求后序序列
