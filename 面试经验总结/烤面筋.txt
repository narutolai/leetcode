1.Linux进场调度算法有哪些？选两个最了解的介绍一下#https://www.cnblogs.com/lyl-312/p/5578945.html
fcfs：先来先服务
短作业优先调度：
轮转法：让每个进程在就绪队列中的等待时间与享受服务的时间成正比例
多级反馈队列算法：
2.简述tcp的三次握手四次挥手
#https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc
URG：紧急指针（urgent pointer）有效。
ACK：确认序号有效。
PSH：接收方应该尽快将这个报文交给应用层。
RST：重置连接。
SYN：发起一个新连接。
FIN：释放一个连接
三次握手：
客户端主动发起连接，服务器被动
SYN=1表示发起一个新连接。
      SYN=1,seq=x
客户端----------->服务端        
      SYN=1,seq=y,ACK=1, ack=x+1  ack就是服务器告诉客户端说下波你要发seq=x+1的数据给我。
客户端<-----------服务端
      ACK=1 seq=x+1 ack=y+1     ACK=1表示收到了你上一个发送的连接请求有效。
客户端------------>服务端


四次挥手
-------数据传输---------
    FIN=1 seq=u
客户端----------->服务端  表示客户端告诉服务器我发送完数据了（发送管道要关闭了哦）
      ACK=1 seq=v ack=u+1
客户端<-----------服务端   服务端回复它：好的收到！
<-------数据传输-------------
<-------数据传输-------------
<-------数据传输------------- 客户端停止了不表示服务器端也停止了。
<-------数据传输-------------  
      FIN=1  ACK=1 seq=w ack=u+1   ! 注意为什么这个ack是u+1呢 因为客户端已经停止发送数据了，所以服务端一直是ack=u+1!!
客户端<-----------服务端   服务端说：我也发完数据了，要关闭了哦
      ACK=1  seq=u+1 ack=w+1
客户端----------->服务端    客户端说回复它：好的 收到！ 

3.stl的map和unordered_map怎么实现的？这个之前有。
4.Linux内核的内存管理算法。
5.段页式的原理和需要几次访存，页面替换算法

6.Linux的fork实现

7.tcp/ip协议的准确性是怎么样保证的？

8.布隆过滤器 什么是缓存穿透#https://blog.csdn.net/wuzhiwei549/article/details/106714765/
缓存穿透：用户检索数据发现redis中没有，于是就去数据库中找 然后发现数据库中也没有，一两次这样的操作还好操作
多了redis就形同虚设了,redis就是为了减少访问数据库的次数的啊，这就是相当于redis不存在等于被击穿了。有一个解决方法
我们可以在redis缓存一个空字符串或者特殊字符串，比如&&，下次我们去redis中查询的时候，当取到的值是空或者&&，
我们就知道这个值在数据库中是没有的，就不会在去数据库中查询。


9.c++智能指针有哪些 unique_ptr的实现原理

10.TCP四次挥手后的time_wait的作用是什么

11.tcp的拥塞控制是怎么实现的。

12.leetcode33：Search in rorated Array

13.将链表的后半截逆序然后跟前半截交叉输出；
如1-2-3-4-5   1 5 2 4 3
不许递归 时间复杂n，空间复杂1

14二叉树转为双向链表，找到二叉树中的某种路径使其和为定值。


15进程通信方式

16死锁


